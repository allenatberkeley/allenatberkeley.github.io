
    <h2>Project pipeline</h2>
    <p>
        For this project, we start with a <code>.ply</code> file containing vertices and triangular face indices. This makes it easy to render the meshes provided using <code>MeshEdit</code>. However, all of the <code>.ply</code> files are missing vertex normal data and face normal data. This data is necessary for the Ball-Pivoting Algorithm (BPA), so we had to figure out a way to extract vertex normals from a set of vertices and faces. Our approach was simple, construct the mesh with the provided faces, and use the <code>MeshEdit</code> code we used to compute vertex-based normals (for lighting) and instead use it for creating <code>.txt</code> files that contained the vertex-normal pairs we needed for BPA.
    </p>
    <div class="row">
        <div class="col-md-6 text-center">
            <h3>
                State
            </h3>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <h3>
                Description
            </h3>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>.ply</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>positions</code> <code>face_indices</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p>
                The <code>.ply</code> file is deserialized into a set of <code>positions</code> and <code>face_indices</code>.
            </p>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>positions</code> <code>face_indices</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>positions</code> <code>normals</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p>
                We use <code>MeshEdit</code> to convert face indices into face normals, and then interpolate around a vertex to find vertex normals.
            </p>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>positions</code> <code>normals</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>.txt</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p>
                We serialize the <code>positions</code> and <code>normals</code> to a <code>.txt</code> file in order to access them later. This means we don't have to rely on <code>MeshEdit</code> inside of our BPA code because we already have computed the <code>normals</code>.
            </p>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>.txt</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>positions</code> <code>normals</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p>
                We deserialize the <code>.txt</code> file into a set of <code>positions</code> and <code>normals</code>
            </p>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>positions</code> <code>normals</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>positions</code> <code>face_indices</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p><b>
                This is where the BPA algorithm goes.</b>
                <br> It is the hardest part of the process, and it gives us back the face data.
            </p>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-6 text-center">
            <code>positions</code> <code>face_indices</code>
            <span class="glyphicon glyphicon-arrow-right"></span>
            <code>.ply</code>
        </div>
        <!--Left/Right-->
        <div class="col-md-6 text-center">
            <p>
                Here, we serialize our <code>positions</code> and <code>face_indices</code> into a <code>.ply</code>, and we've basically come full circle. This makes it easy to compare our input <code>.ply</code> and our output <code>.ply</code>.
            </p>
        </div>
    </div>




<!-- INTRODUCTION --> <br>


    <h2>Mesh Reconstruction, Links and References</h2>
    <p>
        <a href="https://cs184team.github.io/cs184-final/">Project Proposal and Background Information</a><br><a href="https://docs.google.com/a/berkeley.edu/presentation/d/10E21GqkAuSqA_eU7CxzZEUKP6ObKn_p21PGVOcP4FZU/edit?usp=sharing">Presentation Slides</a><br>
        Source 1: Fausto Bernardini et al. <a href="http://www.research.ibm.com/vistechnology/pdf/bpa_tvcg.pdf">The Ball-Pivoting Algorithm for Surface Reconstruction</a>
        <br>
        Source 2: Julie Digne, <a href="http://www.ipol.im/pub/art/2014/81/article.pdf">An Analysis and Implementation of a Parallel Ball Pivoting Algorithm</a><br>
    </p>
    <p> 
        We were unable to implement the Poisson Surface Reconstruction. However, we created a <a href="https://youtu.be/CevV4jS45Bc">visual debugger</a> for the Ball-Pivoting Algorithm.
    </p>
    <br>

    <h2>Overview of the Ball-Pivoting Algorithm</h2>
    <p>
        The Ball-Pivoting Algorithm (BPA) is named for the simulated use of a virtual ball to help reconstruct a mesh from a point cloud.
    </p>
    <p>
        To construct the mesh from the point cloud, one first assumes that the given point cloud consists of points sampled from the surface of an object. Points strictly represent a surface, therefore a mesh constructed from those points also represent a surface.
    </p>
    <p>
        Using this assumption, image rolling a tiny ball across a "surface" of points. This tiny ball is dependent on the scale of the mesh, but it should be slightly larger than the average space between points. When you drop a ball onto the surface of points, the ball will get caught and settle upon three points. This is the <em>Seed Triangle</em>: the three points propping the ball up form a triangle, which becomes part of the mesh. From that location, the ball can roll in any direction. Roll the ball, pivoting along the triangle edge formed from two points. The ball then settles in a new location: a new triangle is formed from two of the previous vertices and one new point, the <em>Expansion Triangle</em> is added to the mesh. As we continue rolling and pivoting the ball, new triangles are formed and added to the mesh. The ball continues rolling and rolling until the mesh is fully formed.
    </p>

    <p>
        The following is a 2D visualiziation of the BPA, wherein a ball rolls and settles between pairs of points. Whenever the ball settles, the two points are connected to fill in the mesh. In the 3D case, the ball settles between a triplet of points and the triplet is connected.
    </p>
    <img src="images/roll.png" class="img-responsive center-block"><br>

    <h3>Nuances</h3>
    <p>
        The idea behind the Ball-Pivoting Algorithm is simple, but of course there are many caveats to the procedure:
    </p>

    <ul>
        <li>
            <em>How is the ball radius chosen?</em> The radius, $\rho$, is obtained empirically based on the size and scale of the input point cloud. In theory, the diameter of the ball should be slightly larger than the average distance between points. So, one might calculate $$\rho = 1.25\times(\dfrac{AverageDistance}{2})$$In the case brought up two bullet points below, for multiple radii, one could scale the original radius to obtain smaller or larger radii. For example, one might use a factor of $2$, $\{0.5\rho, 1.0\rho, 2.0\rho\}$ or a factor of $10$, $\{0.1\rho, 1.0\rho, 10\rho\}$.
        </li>
        <br>
        <li>
            <em>What if the sampled points are too far apart at some locations and the ball "falls through" the surface?</em> When the ball pivots along an edge, it may miss the appropriate point on the surface and instead hit another point on the object or even exactly its three old points. In this case, we check that the normal of the new triangle <code>Facet</code> is consistently oriented with the point's <code>Vertex</code> normals. If it is not, then we reject that triangle.
        </li>
        <br>
        <li>
            <em>What if the surface has a crease or valley, such that the distance between the surface and itself is less than the size of the ball?</em> In this case, the ball would just roll over the crease and ignore the points within the crease. But, this is not ideal behavior as the reconstructed mesh is not accurate to the object. To fix this, multiple ball radii must be used in BPA: the smaller balls are able to roll into the crease and construct that part of the surface; the larger balls would prevent the "fall throughs" noted in the above point and improve surface continuity.
        </li>
        <br>
        <li>
            <em>What if the surface is spaced into regions of points such that the ball cannot successfully roll between the regions?</em> The virtual ball is dropped onto the surface multiple times at varying locations. (Actually, our implementation has the ball drop onto all unprocessed sets of three points.) This ensures that the ball captures the entire mesh, even when the points are inconsistently spaced out.
        </li>
    </ul>
    <p>
        Additional peculiarities are discussed within the Algorithm sections below.
    </p>



<!-- DATA STRUCTURES --> <br>


    <h2>Data Structure: VoxelArray</h2>
    <p>
        The Ball-Pivoting Algorithm is run on a <code>.txt</code> file, which contains an unordered set of <code>positions</code> and <code>normals</code> for each respective point in the point cloud. A point's <code>position</code> and <code>normal</code> is stored in the <code>Vertex</code> structure; and, the set of <code>Vertex</code>s are stored in the "<code>Cloud</code>." In order for the BPA algorithm to work, we need a method to access all of the points within a given radius of any local point. To "roll" the ball we need quick access to all of the neighboring points to a local point. At most for the BPA, we need to obtain all points within $2\rho$ distance from the local point. To allow these queries for neighboring points, we created the <code>VoxelArray</code> data structure.
    </p>
    <p>
        The <code>VoxelArray</code> is a 3D grid of cubic voxels, each voxel having side lengths of $2\rho$. With this voxel side length, we can successfully obtain all of the neighboring points: all points within $2\rho$ of the local point are contained within the local (center) voxel and it's 26 neighboring voxels. (Which constitutes a $3$x$3$x$3$ voxels, $6\rho$ length cube.) The points contained within the 27 local voxels can then be quickly filtered and sorted based on their distances from the local point.
    </p>
    <p>
        The <code>VoxelArray</code> structure has both advantages and disadvantages.
    </p>
    <p> Advantages </p>
    <ul>
        <li>Fast voxel access: The voxels are all indexed in the <code>VoxelArray</code> for constant time access. Each voxel is a vector container of contained points.</li>
        <li>Intuitive internal structure: Voxels' indices are a flattened value based upon the integer x-, y-, and z-coordinates of the voxel. Float coordinates can simply be truncated into integers for indexing. Neighboring voxels can be found by $\pm 1$ to the integer x-, y-, and z-coordinates.</li>
    </ul>
    <p> Disadvantages </p>
    <ul>
        <li>Memory intensive: The entire space of the point cloud is contained within the <code>VoxelArray</code> cube, whose voxels are all indexed and reserved. The amount of memory reserved is directly proportional to the size of the mesh, and inversely prportional to the input radius $\rho$.</li>
        <li>Empty voxels: Voxels are still allocated space on the memory even when no points are contained within its volume.</li>
    </ul>

    <h2>Data Structures: Vertex, Edge, Facet</h2>
    <p>
        Our BPA implementation uses a mixture of <code>Vertex</code>s, <code>Edge</code>s, and <code>Facet</code>s in order to represent the reconstructed mesh. We do not explicitly need any "mesh" structure which encompasses <code>Vertex</code>, <code>Edge</code>, <code>Facet</code>, because of the nature of the <code>.ply</code> format. <code>.ply</code> files only need to store point positions and faces, which are triangles indexing the points, to represent a mesh. So our final output only requires that we keep track of a list of <code>Vertex</code>s, which contain point positions, and a list of <code>Facet</code>s, which contain sets of 3 <code>Vertex</code>s.
    </p>
    <h4>Vertex</h4>
    <p>
        A <code>Vertex</code> contains a 3D vector containing a point's position and the point's normal. These two pieces of data are gathered from the input <code>.txt</code> file. All of the points are stored in the "Point <code>Cloud</code>." The <code>Cloud</code> is simply a <code>std::vector</code> of <code>Vertex</code>s. This also happens to be the list of points used in the final output.
    </p>
    <p>
        A <code>Vertex</code> also has a flag indicating whether the it is an inner vertex, which signifies that it has already been included within the reconstructed parts of the mesh -- whether it has already been processed.
    </p>
    <h4>Edge</h4>
    <p>
        An <code>Edge</code> contains pointers to its two <code>Vertex</code>s and two <code>Facet</code>s.
    </p>
    <p>
        Additionally, it holds two flags of whether if (1) it is an inner edge, and if (2) it is on a boundary. An inner edge has already been processed and is part of the mesh. A boundary edge is on the border of the mesh: the surface is on one side of this edge and no further surface is on the other side of this edge. A boundary edge is essentially a "cliff" or "crack" in the mesh, when the physical object was improperly sampled or surface data is missing.
    </p>
    <h4>Facet</h4>
    <p>
        A <code>Facet</code> is a triangle which contains pointers to its three <code>Vertex</code>s.
    </p>
    <p>
        Upon creation, the three <code>Vertex</code>s are oriented such that the <code>Facet</code> surface normal is in the same direction as each <code>Vertex</code>'s normal. This ensures that the resulting mesh has consistently oriented triangles. Additionally upon creation, the <b>circumcenter</b> and <b>circumradius</b> of the <code>Facet</code> is calculated: these values are used in the virtual pivoting of the ball. The center of the $\rho$-circumsphere of the <code>Facet</code> on the positive normal side is also calculated.
    </p>



<!-- VISUAL DEBUGGER --> <br>


    <h2>Visual Debugger</h2>
    <p>
        In addition to implementing BPA, we created a visual debugger. It renders the creation of <em>Seed Triangles</em> and <em>Expansion Triangles</em> in real time. Additionally, the BPA function calls can be paused and stepped through triangle-by-triangle.
    </p>
    <p>
        <a href="https://youtu.be/CevV4jS45Bc">Video demo of BPA run on the Dragon point cloud.</a> Multiple radii were used, this can be seen as the multiple passes of the BPA when holes in the mesh get filled in. During the demo, the camera zooms in at around <a href="https://youtu.be/CevV4jS45Bc?t=30s">0:30</a>: the <font color="#41A317">green</font> triangles are <em>Seed Triangles</em>, the <font color="#EAC117">yellow</font> triangles are <em>Expansion Triangles</em>, the <font color="#F70D1A">red</font> triangles are <em>Hole Filling Triangles</em>, which are discussed in the Hole Filling Case below.
    </p>
    <p>
        For the sake of the demo, smaller radii were used. A large input radius $\rho$ would cause the BPA to run extremely slowly under the visual debugger. This is because the <code>VoxelArray</code> creates Voxels of size $2\rho$, so larger $\rho$ values lead to a greater amount of neighboring points which must be processed while "rolling the ball."
    </p>
    <p>
        In creating the render-debugger, we needed two threads to accomplish the asynchronous rendering and meshing. The main thread renders the model, and receives new triangles via three separate callbacks for <em>Seed Triangles</em>, <em>Expansion Triangles</em>, and <em>Hole-filling Triangles</em>. The meshing thread just runs the BPA meshing algorithm, and sends triangles to the main thread through callbacks given to the Mesher object from the main thread.
    </p>

    <h3>Vertex Normal Debugger</h3>
    <p>
        In addition to the BPA visual debugger, we created a vertex normal debugger, for the <code>.ply</code><span class="glyphicon glyphicon-arrow-right"></span><code>.txt</code> conversion part of the <b>Project Pipeline</b>.
    </p>
    <p>
         We couldn't think of a way to test our code for creating vertex normals without viewing the normals, and our initial rendering code would just display the point cloud like this:
    </p>
    <img src="images/points.png" class="img-responsive center-block">
    <p>
        We decided to add some code to display the normals, but no matter what depth we viewed them at, it was difficult to tell whether or not they were oriented correctly.
    </p>
    <img src="images/white1.png" class="img-responsive center-block">
    <img src="images/white2.png" class="img-responsive center-block">
    <img src="images/white3.png" class="img-responsive center-block">
    <p>
        Finally, we had the idea of adjusting a few parameters to make visual vertex normal debugging possible.
    </p>
    <ul>
        <li>Extend the length of the normal vector</li>
        <li>Decrease the far-clip of the camera</li>
        <li>Make the vertices red</li>
        <li>Make the normal vectors blue</li>
        <li>Make the end of the normal vectors green</li>
    </ul>
    <p>
         Then, if we zoom in on the mesh, we should see green before we see red, which would tell us that the normals are indeed facing outwards.
    </p>
    <img src="images/1.png" class="img-responsive center-block">
    <img src="images/2.png" class="img-responsive center-block">
    <img src="images/3.png" class="img-responsive center-block">
    <p>
        Using this method, we were able to verify our code for calculating vertex normals and produce the <code>.txt</code> data we needed, which has this format:
    </p>
    <pre>
        vx1 vy1 vz1 nx1 ny1 nz1
        vx2 vy2 vz2 nx2 ny2 nz2
        .   .   .   .   .   .
        .   .   .   .   .   .
        .   .   .   .   .   .
        vxm vym vzm nxm nym nzm
    </pre>
    <p>
        Here is an example:
    </p>
    <pre>
        5.89458 11.7884 27.2832 -0.83141 -0.404449 0.381023
        -53.3251 67.1044 -57.4501 -0.878005 -0.293709 0.377946
        3.75049 16.5054 29.454 -0.736516 -0.579169 0.349439
        -40.0742 -33.2375 10.7422 -0.859218 -0.0742719 0.50619
        -52.8133 67.0694 -57.5725 -0.844274 -0.203288 0.495858
        -52.4255 66.8347 -57.3804 -0.820147 -0.109775 0.561524
    </pre>
    <br>          



<!-- Algorithms --> <br>


    <h1>The Ball-Pivoting Algorithm</h1>
    <p>
        The BPA takes in a oriented point <code>Cloud</code> of <code>Vertex</code>s. That is, each point has a position and a normal. Additionally, BPA requires a user-given radius or set of radii.
    </p>
    <p>
        While the <b>Find Seed Triangle</b> algorithm completes successfully, we call <b>Expand Triangulation</b> on the returned <em>Seed Triangle</em>. Otherwise, we break and the BPA is completed for the given radius. If multiple radii are given, the <b>Find Seed Triangle</b>-<b>Expand Triangulation</b> loop is run again until all radii are used.
    </p>
    <p>
        The conclusion to BPA is a set of <code>Vertex</code>s and a set of <code>Facet</code>s, whose data will be outputted into a <code>.ply</code> file.
    </p>

    <h2>Algorithm: Find Seed Triangle</h2>
    <p>
        <b>Find Seed Triangle</b> iterates throughs the entire point cloud and attempts to find valid <em>Seed Triangles</em>. Iterating through the <code>Cloud</code>, this function searches for two other points in the neighborhood of the current point. The three points must be in <em>Empty Ball Configuration</em> in order to return a valid <code>Facet</code> for <b>Expand Triangulation</b>.
    </p>
    <h4>Empty Ball Configuration</h4>
    <p>
        <em>Empty Ball Configuration</em> signifies that a sphere of radius $\rho$ can be placed onto the three points with no other point contained within that sphere. The sphere is placed such that it is on the positive normal side of the <code>Facet</code> that would be formed by those three points. The intuitive reasoning behind the <em>Empty Ball Configuration</em> is that we want to drop the ball onto the surface of the object: if some other point is contained within the ball at any time, then the ball has essentially clipped through the physical surface of the object. We want the ball to be strictly on the surface, so that the created <code>Facet</code>s do in fact represent the surface of the object.
    </p>

    <h2>Algorithm: Expand Triangulation</h2>
    <p>
        <b>Expand Triangulation</b> takes in a <code>Facet</code> returned by <em>Seed Triangle</em> and uses that <code>Facet</code> to start the <em>Edge Front</em>. The <em>Edge Front</em> is a queue of <code>Edge</code>s that the ball can pivot over and create a new triangle <code>Facet</code> for the final mesh. Within a loop, an edge is popped off the <em>Edge Front</em> and a ball is pivoted over that edge: A valid <code>Vertex</code> may be returned by <b>Find Candidate</b>. If so, the new valid point and the two points of the pivot edge form a new <code>Facet</code> for the mesh. Then the two new <code>Edge</code>s, formed by the first old point + the new point, and the second old point + the new point, are pushed on to the <em>Edge Front</em> queue (if they are still available). The loop continues until the <em>Edge Front</em> is empty: new <code>Edge</code>s are not always added to the <em>Edge Front</em>.
    </p>
    <p>
        Throughout the entire loop, we must ensure that the <code>Edge</code>s being used are still valid and are available to be used. That is, we must make sure each <code>Edge</code> has at most two adjacent <code>Facet</code>s: if so then the <code>Edge</code> is marked as an inner edge, its job is finished and cannot be used anymore. If <b>Find Candidate</b> does not return a valid <code>Vertex</code> upon which the ball pivots onto, the <code>Edge</code> is marked as a boundary edge -- it only has one adjacent <code>Facet</code>, but its job is finished nonetheless. The ball in <b>Expand Triangulation</b> never pivots over any edge already tagged as inner or boundary, these edges are removed from the <em>Edge Front</em>.
    </p>

    <h3>Case: Hole-Filling Triangle</h3>
    <p>
        <em>Hole-Filling Triangles</em> are a special variant of <em>Expansion Triangles</em>. These are triangles that essentially fill in the hole as two <em>Edge Fronts</em> collide with each other or an <em>Edge Front</em> with itself. A <em>Hole-Filling Triangle</em> results from a ball pivoting upon a popped pivot <code>Edge</code>, and the two resulting <code>Edges</code> adjacent to the new <code>Facet</code> are both on an <em>Edge Front</em>. This means that all of the three <code>Edge</code>s adjacent to the <code>Facet</code> are marked as inner. The local region of the mesh is completely filled.
    </p>
    <p>
        <em>Hole-Filling Triangles</em> also appear in a post-processing step. For a variety of reasons (points too far apart, bad normal processing, etc.) a mesh may contain unintentional holes in its surface. Thus we check that if any three boundary <code>Edge</code>s form an oriented loop, they do in fact form a valid triangle. This triangle made from boundary <code>Edge</code>s is also a <em>Hole-Filling Triangle</em>.
    </p>

    <h2>Algorithm: Find Candidate</h2>
    <p>
        Called by <b>Expand Triangulation</b>, given an <code>Edge</code> this function returns a valid <code>Vertex</code> upon which the ball can pivot onto. (Or returns <code>null</code>, indicating that there are no points available to pivot towards and the given <code>Edge</code> should be marked as boundary.) <b>Essentially, this function simulates the rolling of the ball: the first point that the ball hits while pivoting is returned.</b>
    </p>
    <p>
        To find a valid candidate <code>Vertex</code>, let the given <code>Edge</code> be $e$, let $c = (center\ of\ \rho$-$circumsphere\ of\ existing\ Facet\ adjacent\ to\ e)$ and let $m = (midpoint\ of\ e)$. We calculate $\rho' = ||m - c|| + \rho$. This $\rho'$ is the distance from $m$ to the center of the ball as the ball pivots around $e$, at all orientations of the ball. Then, we query the <code>VoxelArray</code> for all points within $2\rho'$ distance to $m$, sorted in order of increasing distance. The returned points are all of the points the ball can possibly hit while pivoting upon $e$. We then find a <code>Vertex</code> $v$ such that $v$:
        <ul>
            <li>$v$ is not an inner <code>Vertex</code> of the mesh, and is not either of $e$'s two <code>Vertex</code>s.</li>
            <li>$v$ is <em>compatible</em> with $e$. That is, the <code>Facet</code> $f_{new}$ formed by $v$ and $e$ has a normal oriented in the same direction as the normals of $v$ and $e$'s <code>Vertex</code>s. (All three dot products are positive.)</li>
            <li>the $f_{new}$ triangle has a circumcenter that exists: the square circumradius is less than $\rho$. Essentially, the ball fits onto the three new points and does not fall through.</li>
            <li>$v$ and $e$ are in <em>Empty Ball Configuration</em>.</li>
            <li>The angle between $e$'s old <code>Facet</code> and $f_{new}$ is minimized: the returned $v$ is the first point that the ball hits while pivoting.
        </ul>
        Iterating through all of the neighboring points, the $v$ meeting the above conditions is returned. Otherwise, <code>null</code> is returned.
    </p>

    <h2>Multiple Radii and Post-Processing</h2>
    <p>
        The BPA is run multiple times with varying radii to improve the accuracy of the output mesh. We first run BPA with the smallest radii, which fills in the smallest creases of the mesh (as mentioned in section <b>Nuances</b>). Then BPA is run with increasing radii until all input radii have been processed. Each time, BPA is run on points not contained in an <code>Edge</code> AND the points that are contained within <em>boundary edges</em>. The latter is because the <code>Edge</code>s marked as being on a boundary cannot find a valid <em>Candidate Vertex</em> due to $\rho$ being too small on the previous BPA runs.
    </p>
    <p>
        After finishing up with running the list of radii, a <em>Hole-Filling</em> post-processing step is run. For a variety of reasons (points too far apart, bad normal processing, etc.) a mesh may contain unintentional holes in its surface. Thus we check that if any three boundary <code>Edge</code>s form an oriented loop, they do in fact form a valid triangle. This triangle made from the boundary <code>Edge</code>s is a <em>Hole-Filling Triangle</em>.
    </p>

    



<!-- Results/Conclusion --> <br>

    <h2>Results</h2>
    <p>
        
    </p>

    <h2>Conclusions</h2>
    <p>
        We had initially set out for implementing both BPA and the Poisson Reconstruction, though throughout the course of the workload we had shifted focus to implementing BPA and creating a way to visualize our BPA algorithm in real time. Our implementation is run faster on the command line with no visualizer.
    </p>
    <p>
        As we increase the input radius $\rho$, the running of BPA slows down proportionally. This is because the size of the Voxels inside the <code>VoxelArray</code> is dependent on $\rho$, specifically their side length is $2\rho$. Larger $\rho$ values lead to a greater amount of neighboring points which must be processed per local point while rolling the ball.
    </p>
    <p>
        So to create as complete of a mesh as possible, we must use a wide range of input radii. Processing time to create a complete mesh is rather significant, especially if arbitrary input radii are used.
    </p>
    <p>
        Efficient data structures are key for faster BPA processing and for visual debug rendering. And visual demos on smaller data sets are great for illustrating what is occuring step-by-step within the algorithm, helping with debugging.
    </p>



<!-- Contributions --> <br>

    <h2>Contributions</h2>
    <p>
        We all worked on the project together, and had significant inputs during all parts of the project. For the project proposal, work was split pretty evenly. <br>For the coding, Michael did a majority of the actual typing and Allen typed a few of the data structures. While typing is an individual task, all team members were present and contributing intellectually to the code. All members worked together to understand the Ball-Pivoting algorithm and catch edge cases. <br>Brett created the presentation slides and designed the flow of the presentation. Michael and Allen helped fill in the presentation slides, adding especially to the parts they respectively presented. <br>Allen wrote the majority of the writeup's body. Brett and Michael contributed to the Debugger sections; and the Results and Conclusions sections especially.
    </p>


